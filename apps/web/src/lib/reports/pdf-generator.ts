import { PDFDocument, StandardFonts, rgb, PDFPage } from 'pdf-lib';
import { format } from 'date-fns';

interface ReportHeader {
  title: string;
  subtitle?: string;
  organization: string;
  generatedBy: string;
  dateRange?: { start: string; end: string };
}

interface ReportSection {
  title: string;
  content: any[];
  type: 'table' | 'text' | 'list' | 'summary' | 'chart';
}

export class PDFReportGenerator {
  private doc: PDFDocument | null = null;
  private currentPage: PDFPage | null = null;
  private yPosition: number = 0;
  private readonly margin = 50;
  private readonly lineHeight = 20;
  private readonly pageWidth = 595.28; // A4 width in points
  private readonly pageHeight = 841.89; // A4 height in points

  async initialize(): Promise<void> {
    this.doc = await PDFDocument.create();
    this.addPage();
  }

  private addPage(): void {
    if (!this.doc) throw new Error('Document not initialized');
    this.currentPage = this.doc.addPage([this.pageWidth, this.pageHeight]);
    this.yPosition = this.pageHeight - this.margin;
  }

  async addHeader(header: ReportHeader): Promise<void> {
    if (!this.currentPage || !this.doc) throw new Error('Document not initialized');

    const titleFont = await this.doc.embedFont(StandardFonts.HelveticaBold);
    const regularFont = await this.doc.embedFont(StandardFonts.Helvetica);

    // Add logo placeholder (you can embed actual logo here)
    this.currentPage.drawRectangle({
      x: this.margin,
      y: this.yPosition - 40,
      width: 40,
      height: 40,
      color: rgb(0.9, 0.9, 0.9),
    });

    // Title
    this.currentPage.drawText(header.title, {
      x: this.margin + 50,
      y: this.yPosition - 20,
      size: 18,
      font: titleFont,
      color: rgb(0, 0, 0),
    });

    // Subtitle
    if (header.subtitle) {
      this.currentPage.drawText(header.subtitle, {
        x: this.margin + 50,
        y: this.yPosition - 40,
        size: 12,
        font: regularFont,
        color: rgb(0.4, 0.4, 0.4),
      });
    }

    // Organization info
    this.currentPage.drawText(header.organization, {
      x: this.pageWidth - this.margin - 200,
      y: this.yPosition - 20,
      size: 10,
      font: regularFont,
      color: rgb(0.3, 0.3, 0.3),
    });

    // Generated info
    const generatedText = `Generated by: ${header.generatedBy}`;
    this.currentPage.drawText(generatedText, {
      x: this.pageWidth - this.margin - 200,
      y: this.yPosition - 35,
      size: 9,
      font: regularFont,
      color: rgb(0.5, 0.5, 0.5),
    });

    // Date
    const dateText = `Date: ${format(new Date(), 'dd/MM/yyyy HH:mm')}`;
    this.currentPage.drawText(dateText, {
      x: this.pageWidth - this.margin - 200,
      y: this.yPosition - 50,
      size: 9,
      font: regularFont,
      color: rgb(0.5, 0.5, 0.5),
    });

    // Date range if provided
    if (header.dateRange) {
      const rangeText = `Period: ${header.dateRange.start} to ${header.dateRange.end}`;
      this.currentPage.drawText(rangeText, {
        x: this.margin,
        y: this.yPosition - 70,
        size: 10,
        font: regularFont,
        color: rgb(0.3, 0.3, 0.3),
      });
    }

    // Draw separator line
    this.currentPage.drawLine({
      start: { x: this.margin, y: this.yPosition - 85 },
      end: { x: this.pageWidth - this.margin, y: this.yPosition - 85 },
      thickness: 1,
      color: rgb(0.8, 0.8, 0.8),
    });

    this.yPosition -= 100;
  }

  async addSection(section: ReportSection): Promise<void> {
    if (!this.currentPage || !this.doc) throw new Error('Document not initialized');

    const titleFont = await this.doc.embedFont(StandardFonts.HelveticaBold);
    const regularFont = await this.doc.embedFont(StandardFonts.Helvetica);

    // Check if we need a new page
    if (this.yPosition < 100) {
      this.addPage();
    }

    // Section title
    this.currentPage.drawText(section.title, {
      x: this.margin,
      y: this.yPosition,
      size: 14,
      font: titleFont,
      color: rgb(0, 0, 0),
    });
    this.yPosition -= 30;

    // Section content based on type
    switch (section.type) {
      case 'summary':
        await this.addSummaryContent(section.content, regularFont);
        break;
      case 'table':
        await this.addTableContent(section.content, regularFont);
        break;
      case 'list':
        await this.addListContent(section.content, regularFont);
        break;
      case 'text':
        await this.addTextContent(section.content, regularFont);
        break;
      default:
        break;
    }

    this.yPosition -= 20; // Space between sections
  }

  private async addSummaryContent(content: any[], font: any): Promise<void> {
    if (!this.currentPage) return;

    content.forEach((item) => {
      if (this.yPosition < 50) {
        this.addPage();
      }

      // Draw summary box
      this.currentPage!.drawRectangle({
        x: this.margin,
        y: this.yPosition - 60,
        width: this.pageWidth - (2 * this.margin),
        height: 50,
        borderColor: rgb(0.8, 0.8, 0.8),
        borderWidth: 1,
      });

      // Label
      this.currentPage!.drawText(item.label, {
        x: this.margin + 10,
        y: this.yPosition - 25,
        size: 10,
        font,
        color: rgb(0.5, 0.5, 0.5),
      });

      // Value
      this.currentPage!.drawText(String(item.value), {
        x: this.margin + 10,
        y: this.yPosition - 45,
        size: 16,
        font,
        color: rgb(0, 0, 0),
      });

      this.yPosition -= 70;
    });
  }

  private async addTableContent(content: any[], font: any): Promise<void> {
    if (!this.currentPage || !content.length) return;

    const columnWidth = (this.pageWidth - (2 * this.margin)) / Object.keys(content[0]).length;
    const rowHeight = 25;

    // Table headers
    if (content.length > 0) {
      const headers = Object.keys(content[0]);
      headers.forEach((header, index) => {
        this.currentPage!.drawText(header, {
          x: this.margin + (index * columnWidth) + 5,
          y: this.yPosition,
          size: 10,
          font,
          color: rgb(0, 0, 0),
        });
      });

      // Header line
      this.currentPage!.drawLine({
        start: { x: this.margin, y: this.yPosition - 5 },
        end: { x: this.pageWidth - this.margin, y: this.yPosition - 5 },
        thickness: 1,
        color: rgb(0.6, 0.6, 0.6),
      });

      this.yPosition -= rowHeight;

      // Table rows
      content.forEach((row) => {
        if (this.yPosition < 50) {
          this.addPage();
        }

        Object.values(row).forEach((value: any, index) => {
          const text = String(value).substring(0, 20); // Truncate long text
          this.currentPage!.drawText(text, {
            x: this.margin + (index * columnWidth) + 5,
            y: this.yPosition,
            size: 9,
            font,
            color: rgb(0.2, 0.2, 0.2),
          });
        });
        this.yPosition -= rowHeight;
      });
    }
  }

  private async addListContent(content: any[], font: any): Promise<void> {
    if (!this.currentPage) return;

    content.forEach((item) => {
      if (this.yPosition < 50) {
        this.addPage();
      }

      const text = `â€¢ ${item}`;
      this.currentPage!.drawText(text, {
        x: this.margin + 10,
        y: this.yPosition,
        size: 10,
        font,
        color: rgb(0.2, 0.2, 0.2),
      });
      this.yPosition -= this.lineHeight;
    });
  }

  private async addTextContent(content: any[], font: any): Promise<void> {
    if (!this.currentPage) return;

    content.forEach((paragraph) => {
      if (this.yPosition < 50) {
        this.addPage();
      }

      // Simple text wrapping (you might want to improve this)
      const words = paragraph.split(' ');
      let line = '';
      const maxWidth = this.pageWidth - (2 * this.margin);
      const fontSize = 10;

      words.forEach((word: string, index: number) => {
        const testLine = line + word + ' ';
        const textWidth = font.widthOfTextAtSize(testLine, fontSize);

        if (textWidth > maxWidth && line !== '') {
          this.currentPage!.drawText(line.trim(), {
            x: this.margin,
            y: this.yPosition,
            size: fontSize,
            font,
            color: rgb(0.2, 0.2, 0.2),
          });
          line = word + ' ';
          this.yPosition -= this.lineHeight;

          if (this.yPosition < 50) {
            this.addPage();
          }
        } else {
          line = testLine;
        }

        if (index === words.length - 1 && line !== '') {
          this.currentPage!.drawText(line.trim(), {
            x: this.margin,
            y: this.yPosition,
            size: fontSize,
            font,
            color: rgb(0.2, 0.2, 0.2),
          });
          this.yPosition -= this.lineHeight;
        }
      });

      this.yPosition -= 10; // Paragraph spacing
    });
  }

  async addFooter(): Promise<void> {
    if (!this.doc) throw new Error('Document not initialized');

    const font = await this.doc.embedFont(StandardFonts.Helvetica);
    const pages = this.doc.getPages();

    pages.forEach((page, index) => {
      // Page number
      const pageText = `Page ${index + 1} of ${pages.length}`;
      page.drawText(pageText, {
        x: this.pageWidth / 2 - 30,
        y: 30,
        size: 9,
        font,
        color: rgb(0.5, 0.5, 0.5),
      });

      // Footer text
      const footerText = 'Generated by SiteProof - Confidential';
      page.drawText(footerText, {
        x: this.margin,
        y: 20,
        size: 8,
        font,
        color: rgb(0.6, 0.6, 0.6),
      });

      // Generation timestamp
      const timestamp = format(new Date(), 'dd/MM/yyyy HH:mm:ss');
      page.drawText(timestamp, {
        x: this.pageWidth - this.margin - 100,
        y: 20,
        size: 8,
        font,
        color: rgb(0.6, 0.6, 0.6),
      });
    });
  }

  async save(): Promise<Uint8Array> {
    if (!this.doc) throw new Error('Document not initialized');
    await this.addFooter();
    return await this.doc.save();
  }

  async saveAsBase64(): Promise<string> {
    if (!this.doc) throw new Error('Document not initialized');
    await this.addFooter();
    return await this.doc.saveAsBase64();
  }
}