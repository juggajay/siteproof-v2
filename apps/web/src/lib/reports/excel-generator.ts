import * as XLSX from 'xlsx';
import { format } from 'date-fns';

interface ExcelReportData {
  title: string;
  organization: string;
  generatedBy: string;
  dateRange?: { start: string; end: string };
  sheets: ExcelSheet[];
}

interface ExcelSheet {
  name: string;
  data: any[];
  columns?: string[];
  summary?: { [key: string]: any };
}

export class ExcelReportGenerator {
  private workbook: XLSX.WorkBook;

  constructor() {
    this.workbook = XLSX.utils.book_new();
  }

  generateReport(data: ExcelReportData): Buffer {
    // Add metadata (Props is not available in the basic xlsx library)
    // Metadata would need the Pro version or a different approach

    // Create summary sheet
    this.addSummarySheet(data);

    // Add data sheets
    data.sheets.forEach((sheet) => {
      this.addDataSheet(sheet);
    });

    // Generate buffer
    return XLSX.write(this.workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  private addSummarySheet(data: ExcelReportData): void {
    const summaryData = [
      ['Report Summary'],
      [],
      ['Report Title:', data.title],
      ['Organization:', data.organization],
      ['Generated By:', data.generatedBy],
      ['Generated Date:', format(new Date(), 'dd/MM/yyyy HH:mm')],
    ];

    if (data.dateRange) {
      summaryData.push(
        ['Report Period:', `${data.dateRange.start} to ${data.dateRange.end}`]
      );
    }

    summaryData.push(
      [],
      ['Sheet Index:'],
      ...data.sheets.map((sheet, index) => [`${index + 1}. ${sheet.name}`])
    );

    const ws = XLSX.utils.aoa_to_sheet(summaryData);

    // Style the summary sheet (column widths)
    ws['!cols'] = [
      { wch: 20 }, // Column A
      { wch: 50 }, // Column B
    ];

    // Add cell styling (if using the Pro version of SheetJS)
    // This is a basic implementation - you might want to use a more advanced library
    // for better styling support

    XLSX.utils.book_append_sheet(this.workbook, ws, 'Summary');
  }

  private addDataSheet(sheet: ExcelSheet): void {
    let ws: XLSX.WorkSheet;

    if (sheet.data.length === 0) {
      // Empty sheet with message
      ws = XLSX.utils.aoa_to_sheet([['No data available']]);
    } else {
      // Create worksheet from data
      ws = XLSX.utils.json_to_sheet(sheet.data);

      // Add summary row if provided
      if (sheet.summary) {
        const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
        const summaryRow = range.e.r + 2; // Add 2 rows after last data row

        // Add "Summary" label
        ws[XLSX.utils.encode_cell({ r: summaryRow, c: 0 })] = {
          t: 's',
          v: 'Summary:',
        };

        // Add summary values
        Object.entries(sheet.summary).forEach(([key, value], index) => {
          ws[XLSX.utils.encode_cell({ r: summaryRow + index + 1, c: 0 })] = {
            t: 's',
            v: key,
          };
          ws[XLSX.utils.encode_cell({ r: summaryRow + index + 1, c: 1 })] = {
            t: typeof value === 'number' ? 'n' : 's',
            v: value,
          };
        });

        // Update range
        range.e.r = summaryRow + Object.keys(sheet.summary).length;
        ws['!ref'] = XLSX.utils.encode_range(range);
      }

      // Auto-size columns
      const range = XLSX.utils.decode_range(ws['!ref'] || 'A1');
      const cols: any[] = [];

      for (let C = range.s.c; C <= range.e.c; ++C) {
        let maxWidth = 10; // Minimum width

        for (let R = range.s.r; R <= range.e.r; ++R) {
          const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
          const cell = ws[cellAddress];

          if (cell && cell.v) {
            const cellValue = String(cell.v);
            maxWidth = Math.max(maxWidth, cellValue.length);
          }
        }

        cols.push({ wch: Math.min(maxWidth + 2, 50) }); // Cap at 50 characters
      }

      ws['!cols'] = cols;
    }

    // Sanitize sheet name (Excel has restrictions)
    const safeName = sheet.name
      .replace(/[\[\]\*\/\\\?:]/g, '')
      .substring(0, 31); // Excel max sheet name length

    XLSX.utils.book_append_sheet(this.workbook, ws, safeName);
  }

  static generateProjectSummaryExcel(projectData: any): Buffer {
    const generator = new ExcelReportGenerator();

    const reportData: ExcelReportData = {
      title: `Project Summary - ${projectData.name}`,
      organization: projectData.organization_name || 'Unknown',
      generatedBy: projectData.requested_by || 'System',
      dateRange: projectData.date_range,
      sheets: [
        {
          name: 'Project Overview',
          data: [
            {
              'Project Name': projectData.name,
              'Client': projectData.client_name,
              'Status': projectData.status,
              'Start Date': projectData.start_date,
              'Due Date': projectData.due_date,
              'Progress': `${projectData.progress || 0}%`,
            },
          ],
        },
        {
          name: 'Daily Diaries',
          data: projectData.diaries || [],
          summary: {
            'Total Entries': projectData.diaries?.length || 0,
          },
        },
        {
          name: 'Inspections',
          data: projectData.inspections || [],
          summary: {
            'Total Inspections': projectData.inspections?.length || 0,
            'Pass Rate': projectData.pass_rate || 'N/A',
          },
        },
        {
          name: 'NCRs',
          data: projectData.ncrs || [],
          summary: {
            'Total NCRs': projectData.ncrs?.length || 0,
            'Open': projectData.open_ncrs || 0,
            'Closed': projectData.closed_ncrs || 0,
          },
        },
      ],
    };

    return generator.generateReport(reportData);
  }

  static generateDailyDiaryExcel(diaryData: any[]): Buffer {
    const generator = new ExcelReportGenerator();

    const reportData: ExcelReportData = {
      title: 'Daily Diary Export',
      organization: 'SiteProof',
      generatedBy: 'System',
      sheets: [
        {
          name: 'Daily Entries',
          data: diaryData.map((entry) => ({
            Date: format(new Date(entry.diary_date), 'dd/MM/yyyy'),
            'Site': entry.site_name || 'N/A',
            'Weather': entry.weather?.description || 'N/A',
            'Temperature': entry.weather?.temperature ? `${entry.weather.temperature}Â°C` : 'N/A',
            'Workers': entry.workforce_count || 0,
            'Equipment': entry.equipment?.length || 0,
            'Activities': entry.activities || 'N/A',
            'Issues': entry.issues || 'None',
            'Created By': entry.created_by_name || 'Unknown',
          })),
          summary: {
            'Total Days': diaryData.length,
            'Total Workers': diaryData.reduce((sum, d) => sum + (d.workforce_count || 0), 0),
          },
        },
      ],
    };

    return generator.generateReport(reportData);
  }

  static generateInspectionSummaryExcel(inspectionData: any): Buffer {
    const generator = new ExcelReportGenerator();

    const reportData: ExcelReportData = {
      title: 'Inspection Summary Report',
      organization: inspectionData.organization || 'SiteProof',
      generatedBy: inspectionData.requested_by || 'System',
      dateRange: inspectionData.date_range,
      sheets: [
        {
          name: 'Summary',
          data: [
            {
              'Total Inspections': inspectionData.total,
              'Passed': inspectionData.passed,
              'Failed': inspectionData.failed,
              'In Progress': inspectionData.in_progress,
              'Pass Rate': `${inspectionData.pass_rate}%`,
            },
          ],
        },
        {
          name: 'Inspection Details',
          data: inspectionData.inspections || [],
        },
        {
          name: 'By Template',
          data: inspectionData.by_template || [],
        },
        {
          name: 'By Inspector',
          data: inspectionData.by_inspector || [],
        },
      ],
    };

    return generator.generateReport(reportData);
  }

  static generateNCRReportExcel(ncrData: any): Buffer {
    const generator = new ExcelReportGenerator();

    const reportData: ExcelReportData = {
      title: 'NCR Report',
      organization: ncrData.organization || 'SiteProof',
      generatedBy: ncrData.requested_by || 'System',
      dateRange: ncrData.date_range,
      sheets: [
        {
          name: 'NCR Summary',
          data: [
            {
              'Total NCRs': ncrData.total,
              'Open': ncrData.open,
              'In Progress': ncrData.in_progress,
              'Resolved': ncrData.resolved,
              'Closed': ncrData.closed,
              'Average Resolution Time': ncrData.avg_resolution_time || 'N/A',
            },
          ],
        },
        {
          name: 'NCR List',
          data: (ncrData.ncrs || []).map((ncr: any) => ({
            'NCR Number': ncr.ncr_number,
            'Title': ncr.title,
            'Status': ncr.status,
            'Severity': ncr.severity,
            'Raised Date': format(new Date(ncr.raised_date), 'dd/MM/yyyy'),
            'Raised By': ncr.raised_by_name,
            'Assigned To': ncr.assigned_to_name,
            'Due Date': ncr.due_date ? format(new Date(ncr.due_date), 'dd/MM/yyyy') : 'N/A',
            'Closed Date': ncr.closed_date ? format(new Date(ncr.closed_date), 'dd/MM/yyyy') : 'N/A',
          })),
        },
        {
          name: 'By Severity',
          data: ncrData.by_severity || [],
        },
        {
          name: 'By Category',
          data: ncrData.by_category || [],
        },
      ],
    };

    return generator.generateReport(reportData);
  }
}